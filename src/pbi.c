/*
 * pbi.c - Parallel bus emulation
 *
 * Copyright (C) 2002 Jason Duerstock <jason@cluephone.com>
 * Copyright (C) 2007-2008 Perry McFarlane
 * Copyright (C) 2002-2008 Atari800 development team (see DOC/CREDITS)
 *
 * This file is part of the Atari800 emulator project which emulates
 * the Atari 400, 800, 800XL, 130XE, and 5200 8-bit computers.
 *
 * Atari800 is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * Atari800 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Atari800; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include "atari.h"
#include "pbi.h"
#include "memory.h"
#include "pia.h"
#include "cpu.h"
#include "log.h"
#include "util.h"
#ifdef PBI_MIO
#include "pbi_mio.h"
#endif
#ifdef PBI_BB
#include "pbi_bb.h"
#endif
#ifdef PBI_XLD
#include "pbi_xld.h"
#endif
#include <stdlib.h>

/* stores the current state of the D1FF register, read hardware has 1
 * bit per device, the bits are on the devices themselves */
static UBYTE D1FF_LATCH = 0;

/* 1400XL/1450XLD and 1090 have ram here */
int PBI_D6D7ram = FALSE;

/* So far as is currently implmented: PBI_IRQ can be generated by the 1400/1450 Votrax and the Black Box button */
/* Each emulated PBI device will set a bit in this variable to indicate IRQ status */
/* The acutal hardware has only one common line.  The device driver rom has to
 * figure it out*/
int PBI_IRQ = 0;

#ifdef PBI_DEBUG
#define D(a) a
#else
#define D(a) do{}while(0)
#endif

void PBI_Initialise(int *argc, char *argv[])
{
#ifdef PBI_XLD
	PBI_XLD_Initialise(argc, argv);
#endif
#ifdef PBI_BB
	PBI_BB_Initialise(argc, argv);
#endif
#ifdef PBI_MIO
	PBI_MIO_Initialise(argc, argv);
#endif
}

int PBI_ReadConfig(char *string, char *ptr)
{
	if (0) {
	}
#ifdef PBI_XLD
	else if (PBI_XLD_ReadConfig(string, ptr)) {
	}
#endif
#ifdef PBI_MIO
	else if (PBI_MIO_ReadConfig(string, ptr)) {
	}
#endif
#ifdef PBI_BB
	else if (PBI_BB_ReadConfig(string, ptr)) {
	}
#endif
	else return FALSE; /* no match */
	return TRUE; /* matched something */
}

void PBI_WriteConfig(FILE *fp)
{
#ifdef PBI_MIO
	PBI_MIO_WriteConfig(fp);
#endif
#ifdef PBI_BB
	PBI_BB_WriteConfig(fp);
#endif
#ifdef PBI_XLD
	PBI_XLD_WriteConfig(fp);
#endif
}

void PBI_Reset(void)
{
	/* Reset all PBI ROMs */
	PBI_D1_PutByte(0xd1ff, 0);
#ifdef PBI_XLD
	if (PBI_XLD_enabled) PBI_XLD_Reset();
#endif
	PBI_IRQ = 0;
}

UBYTE PBI_D1_GetByte(UWORD addr)
{
	int result = 0xff;
	/* MIO and BB do not follow the spec, they take over the bus: */
#ifdef PBI_MIO
	if (PBI_MIO_enabled) return PBI_MIO_D1_GetByte(addr);
#endif
#ifdef PBI_BB
	if (PBI_BB_enabled) return PBI_BB_D1_GetByte(addr);
#endif
	/* Remaining PBI devices cooperate, following spec */
#ifdef PBI_XLD
	if (PBI_XLD_enabled) result = PBI_XLD_D1_GetByte(addr);
#endif
	if(result != PBI_NOT_HANDLED) return (UBYTE)result;
	/* Each bit of D1FF is set by one of the 8 PBI devices to signal IRQ */
	/* The XLD devices have been combined into a single handler */
	if (addr == 0xd1ff) {
	/* D1FF IRQ status: */
		result = 0;
#ifdef PBI_XLD
		if (PBI_XLD_enabled) result |= PBI_XLD_D1FF_GetByte();
#endif
		/* add more devices here... */
		return result;
	}
	/* addr was not handled: */
	D(printf("PBI_GetByte:%4x:%2x PC:%4x IRQ:%d\n",addr,result,regPC,IRQ));
	return result; /* 0xff */
}

void PBI_D1_PutByte(UWORD addr, UBYTE byte)
{
	static int fp_active = TRUE;
#ifdef PBI_MIO
	if (PBI_MIO_enabled) {
		PBI_MIO_D1_PutByte(addr, byte);
		return;
	}
#endif
#ifdef PBI_BB
	if (PBI_BB_enabled) {
		PBI_BB_D1_PutByte(addr, byte);
		return;
	}
#endif
	/* Remaining PBI devices cooperate, following spec */
	if (addr != 0xd1ff) {
		D(printf("PBI_PutByte:%4x <- %2x\n", addr, byte));
#ifdef PBI_XLD
		if (PBI_XLD_enabled) PBI_XLD_D1_PutByte(addr, byte);
#endif
		/* add more devices here... */
	}
	else if (addr == 0xd1ff) {
		/* D1FF pbi rom bank select */
		D(printf("D1FF write:%x\n", byte));
		if (D1FF_LATCH != byte) {
			/* if it's not valid, ignore it */
			if (byte != 0 && byte != 1 && byte != 2 && byte != 4 && byte != 8 && byte != 0x10 && byte !=0x20 && byte != 0x40 && byte != 0x80){
				D(printf("*****INVALID d1ff write:%2x********\n",byte));
				return;
			}
			/* otherwise, update the latch */
			D1FF_LATCH = byte;
#ifdef PBI_XLD
			if (PBI_XLD_enabled && PBI_XLD_D1FF_PutByte(byte) != PBI_NOT_HANDLED) {
				/* handled */
				fp_active = FALSE;
				return;
			}
#endif
		    /* add more devices here... */
			/* reactivate the floating point rom */
			if (!fp_active) {
				memcpy(memory + 0xd800, atari_os + 0x1800, 0x800);
				D(printf("Floating point rom activated\n"));
				fp_active = TRUE;
			}
		}
	}
}

/* $D6xx */
UBYTE PBI_D6_GetByte(UWORD addr)
{
#ifdef PBI_MIO
	if (PBI_MIO_enabled) return PBI_MIO_D6_GetByte(addr);
#endif
#ifdef PBI_BB
	if(PBI_BB_enabled) return PBI_BB_D6_GetByte(addr);
#endif
	/* XLD/1090 has ram here */
	if (PBI_D6D7ram) return memory[addr];
	else return 0xff;
}

/* $D6xx */
void PBI_D6_PutByte(UWORD addr, UBYTE byte)
{
#ifdef PBI_MIO
	if (PBI_MIO_enabled) {
		PBI_MIO_D6_PutByte(addr,byte);
		return;
	}
#endif
#ifdef PBI_BB
	if(PBI_BB_enabled) {
		PBI_BB_D6_PutByte(addr,byte);
		return;
	}
#endif
	/* XLD/1090 has ram here */
	if (PBI_D6D7ram) memory[addr]=byte;
}

/* read page $D7xx */
/* XLD/1090 has ram here */
UBYTE PBI_D7_GetByte(UWORD addr)
{
	D(printf("PBI_D7_GetByte:%4x\n",addr));
	if (PBI_D6D7ram) return memory[addr];
	else return 0xff;
}

/* write page $D7xx */
/* XLD/1090 has ram here */
void PBI_D7_PutByte(UWORD addr, UBYTE byte)
{
	D(printf("PBI_D7_PutByte:%4x <- %2x\n",addr,byte));
	if (PBI_D6D7ram) memory[addr]=byte;
}


/*
vim:ts=4:sw=4:
*/
